name: Build & Deploy Lambda (ECR image)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-southeast-1
  AWS_ACCOUNT_ID: 641675857341
  LAMBDA_NAME: planner-agent
  ECR_REPOSITORY: planner_agent

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up QEMU
      run: |
        # For standard x86_64 builds this is not required. Keep if building different architectures.
        true

    - name: Configure AWS credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Ensure ECR repository exists
      run: |
        repo="${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.AWS_REGION}}.amazonaws.com/${{env.ECR_REPOSITORY}}"
        if ! aws ecr describe-repositories --repository-names "${{env.ECR_REPOSITORY}}" --region "${{env.AWS_REGION}}" >/dev/null 2>&1; then
          echo "Creating ECR repository ${{env.ECR_REPOSITORY}}"
          aws ecr create-repository --repository-name "${{env.ECR_REPOSITORY}}" --region "${{env.AWS_REGION}}" >/dev/null
        else
          echo "ECR repository ${{env.ECR_REPOSITORY}} already exists"
        fi

    - name: Build Docker image
      run: |
        IMAGE_URI="${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.AWS_REGION}}.amazonaws.com/${{env.ECR_REPOSITORY}}"
        IMAGE_TAG="${GITHUB_SHA::8}-$(date +%s)"
        FULL_TAG="${IMAGE_URI}:${IMAGE_TAG}"
        echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
        echo "FULL_TAG=${FULL_TAG}" >> $GITHUB_ENV
        docker build -t "${FULL_TAG}" .

    - name: Push image to ECR
      run: |
        docker push "${{ env.FULL_TAG }}"

      # --- Update / Publish / Alias (robust handling forImage functions) ---
    - name: Update/Create Lambda (image-aware)
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        LAMBDA_NAME: ${{ env.LAMBDA_NAME }}
        IMAGE_URI: ${{ env.FULL_TAG }}            # previously set earlier in workflow
        LAMBDA_EXEC_ROLE_ARN: ${{ secrets.LAMBDA_EXEC_ROLE_ARN }}  # set this secret to your Lambda exec role ARN
      run: |
        set -euo pipefail

        echo "Using AWS region: $AWS_REGION"
        echo "Target Lambda name: $LAMBDA_NAME"
        echo "Image to deploy: $IMAGE_URI"

        # check current package type
        pkg_type=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region "$AWS_REGION" --query 'Configuration.PackageType' --output text 2>/dev/null || echo "NOT_FOUND")
        echo "Detected packageType: $pkg_type"
        
        echo "Function is Image-based — updating image URI..."
        aws lambda update-function-code --function-name "$LAMBDA_NAME" --image-uri "$IMAGE_URI" --region "$AWS_REGION"
        TARGET_NAME="$LAMBDA_NAME"
      
        echo "Target function for publish: $TARGET_NAME"
        # export the target name for next steps (optional)
        echo "DEPLOYED_FUNCTION=${TARGET_NAME}" >> $GITHUB_ENV

    - name: Wait for update to finish AND verify ImageUri (then publish)
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        # Use DEPLOYED_FUNCTION if earlier steps set it; else fallback to LAMBDA_NAME
        LAMBDA_NAME: ${{ env.DEPLOYED_FUNCTION || env.LAMBDA_NAME }}
        IMAGE_URI: ${{ env.FULL_TAG }}   # the image your workflow pushed (e.g. <acct>.dkr.ecr.<region>.amazonaws.com/repo:tag)
        TIMEOUT_SECS: 360
        POLL_INTERVAL: 5
        MAX_PUBLISH_RETRIES: 6
      run: |
        set -euo pipefail

        echo "Ensuring Lambda '${LAMBDA_NAME}' is updated to image '${IMAGE_URI}' (timeout ${TIMEOUT_SECS}s)..."
        elapsed=0
        # Wait for state Active & LastUpdateStatus Successful
        while true; do
          read -r state last_status last_reason <<<$(aws lambda get-function-configuration \
            --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" \
            --query '[State, LastUpdateStatus, LastUpdateStatusReason]' --output text 2>/dev/null || echo "NOT_FOUND NOT_FOUND NOT_FOUND")

          echo "Poll status: State=${state} LastUpdateStatus=${last_status}"
          if [ "${state}" = "Active" ] && [ "${last_status}" = "Successful" ]; then
            echo "Lambda update status indicates success; proceeding to verify code."
            break
          fi

          if [ "${last_status}" = "Failed" ] || [ "${state}" = "Failed" ]; then
            echo "Lambda update failed: ${last_reason}" >&2
            aws lambda get-function-configuration --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --output json || true
            exit 1
          fi

          if [ "${elapsed}" -ge "${TIMEOUT_SECS}" ]; then
            echo "Timed out waiting for Lambda update to finish after ${elapsed}s" >&2
            aws lambda get-function-configuration --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --output json || true
            exit 1
          fi

          sleep "${POLL_INTERVAL}"
          elapsed=$((elapsed + POLL_INTERVAL))
        done

        # For Image-based functions: verify the Code.ImageUri matches IMAGE_URI
        current_image=$(aws lambda get-function --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --query 'Code.ImageUri' --output text 2>/dev/null || echo "NONE")
        echo "Current ImageUri on function: ${current_image}"

        if [ "${current_image}" != "${IMAGE_URI}" ]; then
          echo "Function does not yet point to the expected image. Waiting until Code.ImageUri matches..."
          # Wait until it matches or timeout
          elapsed=0
          while [ "${current_image}" != "${IMAGE_URI}" ]; do
            if [ "${elapsed}" -ge "${TIMEOUT_SECS}" ]; then
              echo "Timed out waiting for function Code.ImageUri to match expected image. Current: ${current_image}" >&2
              aws lambda get-function --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --output json || true
              exit 1
            fi
            sleep "${POLL_INTERVAL}"
            elapsed=$((elapsed + POLL_INTERVAL))
            current_image=$(aws lambda get-function --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --query 'Code.ImageUri' --output text 2>/dev/null || echo "NONE")
            echo "Polled ImageUri: ${current_image}"
          done
          echo "ImageUri matched expected image."
        else
          echo "ImageUri already matches expected image."
        fi

        # Now publish with retry/backoff for transient ResourceConflictException
        attempt=0
        publish_succeeded=false
        while [ $attempt -lt "${MAX_PUBLISH_RETRIES}" ]; do
          attempt=$((attempt+1))
          echo "Attempt $attempt to publish version..."
          set +e
          out=$(aws lambda publish-version --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" 2>&1)
          rc=$?
          set -e
          if [ $rc -eq 0 ]; then
            # parse JSON to get Version (jq or python)
            if command -v jq >/dev/null 2>&1; then
              VERSION=$(echo "${out}" | jq -r '.Version')
            else
              VERSION=$(echo "${out}" | python -c "import sys,json; print(json.load(sys.stdin)['Version'])")
            fi
            echo "Published version: ${VERSION}"
            echo "NEW_LAMBDA_VERSION=${VERSION}" >> $GITHUB_ENV
            publish_succeeded=true
            break
          else
            echo "Publish failed (rc=$rc): ${out}"
            if echo "${out}" | grep -q "ResourceConflictException"; then
              backoff=$((4 * (2 ** (attempt - 1))))
              echo "ResourceConflictException — backing off ${backoff}s then retrying..."
              sleep "${backoff}"
              continue
            else
              echo "Publish failed with non-retryable error; aborting." >&2
              echo "${out}" >&2
              exit $rc
            fi
          fi
        done

        if [ "${publish_succeeded}" != "true" ]; then
          echo "Failed to publish after ${MAX_PUBLISH_RETRIES} retries." >&2
          aws lambda get-function-configuration --function-name "${LAMBDA_NAME}" --region "${AWS_REGION}" --output json || true
          exit 1
        fi

        # --- Update or create alias 'prod' to the published version ---
        echo "Updating or creating alias 'prod' for version ${VERSION}..."
        
        # Temporarily disable exit-on-error so we can test the command result ourselves
        set +e
        aws lambda get-alias \
          --function-name "${LAMBDA_NAME}" \
          --name prod \
          --region "${AWS_REGION}" >/dev/null 2>&1
        alias_exists=$?
        set -e
        
        if [ $alias_exists -eq 0 ]; then
          echo "Alias 'prod' exists — updating..."
          aws lambda update-alias \
            --function-name "${LAMBDA_NAME}" \
            --name prod \
            --function-version "${VERSION}" \
            --region "${AWS_REGION}"
          echo "Updated alias prod -> ${VERSION}"
        else
          echo "Alias 'prod' does not exist — creating..."
          aws lambda create-alias \
            --function-name "${LAMBDA_NAME}" \
            --name prod \
            --function-version "${VERSION}" \
            --region "${AWS_REGION}" || {
              # if alias already exists (race condition), fall back to update
              echo "CreateAlias reported ResourceConflict — alias already exists, retrying update..."
              aws lambda update-alias \
                --function-name "${LAMBDA_NAME}" \
                --name prod \
                --function-version "${VERSION}" \
                --region "${AWS_REGION}"
            }
          echo "Created or updated alias prod -> ${VERSION}"
        fi


    - name: Extract SAM template from image and deploy
      env:
        IMAGE_URI: ${{ env.FULL_TAG }}           # or use the image variable you already set
        AWS_REGION: ${{ env.AWS_REGION }}
        AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
        LAMBDA_NAME: ${{ env.LAMBDA_NAME }}
      run: |
        set -euo pipefail
        echo "=== Extract template from image and deploy via SAM on runner ==="

        IMAGE="${IMAGE_URI}"
        echo "Using image: $IMAGE"

        # create a transient container (doesn't start processes)
        CID=$(docker create "$IMAGE")
        echo "Created container id: $CID"

        # copy the template from inside the image to the repo workspace (adjust path inside image if needed)
        docker cp "${CID}:/var/app/planner_agent/template.yaml" planner_agent/template.yaml

        # remove transient container
        docker rm "$CID"

        # ensure the template was copied
        test -f planner_agent/template.yaml || (echo "Failed to copy template from image" && exit 1)
        echo "Template copied to planner_agent/template.yaml"

        # install sam cli
        python -m pip install --upgrade pip
        pip install aws-sam-cli --quiet

        # validate, build, deploy (these run on the runner and use OIDC creds already configured)
        #sam validate --template-file planner_agent/template.yaml
        sam build --template-file planner_agent/template.yaml --build-dir .aws-sam/build/planner_agent
        
       # working directory is the repo root (GITHUB_WORKSPACE)        
        sam deploy --template-file .aws-sam/build/planner_agent/template.yaml \
          --stack-name planner-agent-stack \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --parameter-overrides LambdaFunctionArn=${LAMBDA_ARN} ApiName=planner-agent \
          --no-fail-on-empty-changeset

        echo "=== SAM deploy completed successfully ==="
    

    - name: Sleep briefly to allow new image to be available (tiny buffer)
      run: sleep 3

    - name: Smoke test - invoke Lambda
      run: |
        aws lambda invoke --function-name "${LAMBDA_NAME}" --payload '{"name":"CI"}' response.json --region "${{env.AWS_REGION}}"
        cat response.json
        # Simple assertion, fail workflow if we don't see Hello
        grep -q "Hello" response.json
