# .github/workflows/ecr-deploy-lambda.yml
name: Build & Deploy Lambda (ECR image)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-southeast-1
  AWS_ACCOUNT_ID: 641675857341
  LAMBDA_NAME: planner-agent
  ECR_REPOSITORY: planner_agent

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up QEMU (optional for multi-arch builds)
      run: |
        # For standard x86_64 builds this is not required. Keep if building different architectures.
        true

    - name: Configure AWS credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Ensure ECR repository exists
      run: |
        repo="${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.AWS_REGION}}.amazonaws.com/${{env.ECR_REPOSITORY}}"
        if ! aws ecr describe-repositories --repository-names "${{env.ECR_REPOSITORY}}" --region "${{env.AWS_REGION}}" >/dev/null 2>&1; then
          echo "Creating ECR repository ${{env.ECR_REPOSITORY}}"
          aws ecr create-repository --repository-name "${{env.ECR_REPOSITORY}}" --region "${{env.AWS_REGION}}" >/dev/null
        else
          echo "ECR repository ${{env.ECR_REPOSITORY}} already exists"
        fi

    - name: Build Docker image
      run: |
        IMAGE_URI="${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.AWS_REGION}}.amazonaws.com/${{env.ECR_REPOSITORY}}"
        IMAGE_TAG="${GITHUB_SHA::8}-$(date +%s)"
        FULL_TAG="${IMAGE_URI}:${IMAGE_TAG}"
        echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
        echo "FULL_TAG=${FULL_TAG}" >> $GITHUB_ENV
        docker build -t "${FULL_TAG}" .

    - name: Push image to ECR
      run: |
        docker push "${{ env.FULL_TAG }}"

      # --- Update / Publish / Alias (robust handling for Zip vs Image functions) ---
    - name: Update/Create Lambda (image-aware)
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        LAMBDA_NAME: ${{ env.LAMBDA_NAME }}
        IMAGE_URI: ${{ env.FULL_TAG }}            # previously set earlier in workflow
        LAMBDA_EXEC_ROLE_ARN: ${{ secrets.LAMBDA_EXEC_ROLE_ARN }}  # set this secret to your Lambda exec role ARN
      run: |
        set -euo pipefail

        echo "Using AWS region: $AWS_REGION"
        echo "Target Lambda name: $LAMBDA_NAME"
        echo "Image to deploy: $IMAGE_URI"

        # check current package type
        pkg_type=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region "$AWS_REGION" --query 'Configuration.PackageType' --output text 2>/dev/null || echo "NOT_FOUND")
        echo "Detected packageType: $pkg_type"

        if [ "$pkg_type" = "Image" ]; then
          echo "Function is Image-based — updating image URI..."
          aws lambda update-function-code --function-name "$LAMBDA_NAME" --image-uri "$IMAGE_URI" --region "$AWS_REGION"
          TARGET_NAME="$LAMBDA_NAME"

        elif [ "$pkg_type" = "Zip" ]; then
          # Do not overwrite the Zip function. Create a new image-based function for safe migration.
          NEW_NAME="${LAMBDA_NAME}-image-${GITHUB_RUN_ID}"
          echo "Function is Zip-type. Creating Image-based function named ${NEW_NAME} (non-destructive)..."

          aws lambda create-function \
            --function-name "${NEW_NAME}" \
            --package-type Image \
            --code ImageUri="${IMAGE_URI}" \
            --role "${LAMBDA_EXEC_ROLE_ARN}" \
            --region "${AWS_REGION}"

          TARGET_NAME="$NEW_NAME"

        elif [ "$pkg_type" = "NOT_FOUND" ]; then
          echo "Function not found — creating new Image-based function ${LAMBDA_NAME}..."
          aws lambda create-function \
            --function-name "${LAMBDA_NAME}" \
            --package-type Image \
            --code ImageUri="${IMAGE_URI}" \
            --role "${LAMBDA_EXEC_ROLE_ARN}" \
            --region "${AWS_REGION}"
          TARGET_NAME="$LAMBDA_NAME"

        else
          echo "Unexpected packageType: $pkg_type" >&2
          exit 1
        fi

        echo "Target function for publish: $TARGET_NAME"
        # export the target name for next steps (optional)
        echo "DEPLOYED_FUNCTION=${TARGET_NAME}" >> $GITHUB_ENV

    - name: Publish new version & update/create prod alias
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        LAMBDA_NAME: ${{ env.LAMBDA_NAME }}
      run: |
        set -euo pipefail

        # Use the function that was just created/updated
        TARGET_NAME=${DEPLOYED_FUNCTION:-${LAMBDA_NAME}}

        echo "Publishing version for function: $TARGET_NAME"
        VERSION=$(aws lambda publish-version --function-name "$TARGET_NAME" --region "$AWS_REGION" --query 'Version' --output text)
        echo "Published version: $VERSION"

        # export version for later steps
        echo "NEW_LAMBDA_VERSION=$VERSION" >> $GITHUB_ENV

        # create or update alias 'prod'
        if aws lambda get-alias --function-name "$TARGET_NAME" --name prod --region "$AWS_REGION" >/dev/null 2>&1; then
          aws lambda update-alias --function-name "$TARGET_NAME" --name prod --function-version "$VERSION" --region "$AWS_REGION"
          echo "Updated alias prod -> $VERSION for $TARGET_NAME"
        else
          aws lambda create-alias --function-name "$TARGET_NAME" --name prod --function-version "$VERSION" --region "$AWS_REGION"
          echo "Created alias prod -> $VERSION for $TARGET_NAME"
        fi

    - name: Sleep briefly to allow new image to be available (tiny buffer)
      run: sleep 3

    - name: Smoke test - invoke Lambda
      run: |
        aws lambda invoke --function-name "${LAMBDA_NAME}:prod" --payload '{"name":"CI"}' response.json --region "${{env.AWS_REGION}}"
        cat response.json
        # Simple assertion, fail workflow if we don't see Hello
        grep -q "Hello" response.json
